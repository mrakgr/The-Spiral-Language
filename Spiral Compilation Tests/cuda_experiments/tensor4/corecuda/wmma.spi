open corebase

nominal row_major = $"wmma::row_major"
nominal col_major = $"wmma::col_major"

nominal mem_row_major = $"wmma::mem_row_major"
nominal mem_col_major = $"wmma::mem_col_major"

nominal as_mem t = `(
    typecase t with
    | row_major => ``mem_row_major
    | col_major => ``mem_col_major
    )

nominal matrix_a = $"wmma::matrix_a"
nominal matrix_b = $"wmma::matrix_b"
nominal accumulator = $"wmma::accumulator"

nominal tf32 = $"wmma::precision::tf32"
nominal fragment use m n k layout t = $"wmma::fragment<`use, @m, @n, @k, `t, `layout>"

instance index fragment use m n k layout = fun f i => $"!f.x[!i]"
instance set fragment use m n k layout = fun f i v => $"!f.x[!i] = !v"
instance length fragment use m n k layout = fun f => $"!f.num_elements"

open tensorm
open tensorm.cuda

inl create_fragment forall use m n k layout t. : fragment use m n k layout t = real
    typecase use with
    | accumulator => $"wmma::fragment<`use, @m, @n, @k, `t> v$" : fragment use m n k layout t
    | _ => $"wmma::fragment<`use, @m, @n, @k, `t, `layout> v$" : fragment use m n k layout t

inl fragment_dim forall use m n k layout t. (f : fragment use m n k layout t) : int * int = real
    open real_core
    inl a,b =
        typecase use with
        | matrix_a => type_lit_to_lit `m, type_lit_to_lit `k
        | matrix_b => type_lit_to_lit `k, type_lit_to_lit `n
        | accumulator => type_lit_to_lit `m, type_lit_to_lit `n
    typecase layout with
    | row_major => a,b
    | col_major => b,a

inl assert_fragment_dimension forall use m n k layout t el. (f : fragment use m n k layout t) (t : tensor (int * int) el) : () =
    assert (fragment_dim f = t.dim) "The fragment's dimensions must match that of the tensor."

inl load_matrix_sync_array forall use m n k layout t el. (f : fragment use m n k layout t) (ar : array el) (ldm : int) : () =
    real
        typecase use with
        | accumulator =>
            typecase as_mem layout with ~layout => 
            $"wmma::load_matrix_sync(!f, !ar, !ldm, `layout)" : ()
        | _ => 
            $"wmma::load_matrix_sync(!f, !ar, !ldm)" : ()

inl load_matrix_sync forall use m n k layout frag_in t. (f : fragment use m n k layout frag_in) (t : tensor (int * int) t) : () =
    assert_fragment_dimension f t
    load_matrix_sync_array f (ptr_at_current_offset t) (stride_fst t)
    real
        typecase frag_in * t with
        | t * t => ()
        | tf32 * f32 =>
            $"#pragma unroll" : ()
            $"for (int t = 0; t < !f.num_elements; t++) { !f.x[t] = wmma::__float_to_tf32(!f.x[t]); }" : ()
        | _ => real_core.error_type "This type is not supported."

inl store_matrix_sync_array forall use m n k layout t. (ar : array t) (f : fragment use m n k layout t) (ldm : int) : () = 
    real
        typecase use with
        | accumulator =>
            typecase as_mem layout with ~layout => 
            $"wmma::store_matrix_sync(!ar, !f, !ldm, `layout)" : ()
        | _ => 
            $"wmma::store_matrix_sync(!ar, !f, !ldm)" : ()
            
inl store_matrix_sync forall use m n k layout t. (t : tensor (int * int) t) (f : fragment use m n k layout t) : () = 
    assert_fragment_dimension f t
    store_matrix_sync_array (ptr_at_current_offset t) f (stride_fst t)

inl fill_fragment forall use m n k layout t. (f : fragment use m n k layout t) (v : t) : () =  $"wmma::fill_fragment(!f, !v)"
    
inl mma_sync forall m n k a_layout b_layout out_layout t_in t_out. 
        (d : fragment accumulator m n k out_layout t_out) 
        (a : fragment matrix_a m n k a_layout t_in) 
        (b : fragment matrix_b m n k b_layout t_in) 
        (c : fragment accumulator m n k out_layout t_out) 
        : () =
    $"wmma::mma_sync(!d, !a, !b, !c)"